using System;
using System.IO;
using System.Linq;

namespace GaussianFilter
{
    public class GaussianFilter
    {
        public static readonly string[] AllowedImageTypes = new[] {"png", "jpeg", "jpg"};

        /// <summary>
        /// Blurs image with Gaussian filter
        /// </summary>
        /// <param name="sourceImagePath">source image path</param>
        /// <param name="outputImagePath"></param>
        /// <param name="kernelSize"></param>
        /// <param name="standardDeviation"></param>
        public void Apply(string sourceImagePath, string outputImagePath, int kernelSize = 5,
            float standardDeviation = 1f)
        {
            var sourceImageFileInfo = new FileInfo(sourceImagePath);

            if (!sourceImageFileInfo.Exists)
            {
                throw new ArgumentException("sourceImagePath does not point to existing image");
            }

            if (!AllowedImageTypes.Contains(sourceImageFileInfo.Extension))
            {
                throw new ArgumentException("sourceImagePath is not with supported extension. Supported extensions: " +
                                            string.Join(", ", AllowedImageTypes));
            }

            if (string.IsNullOrWhiteSpace(outputImagePath))
            {
                throw new ArgumentNullException(nameof(outputImagePath));
            }

            var image = MatrixUtils.CreateMatrixFromImage(sourceImagePath);
            IMatrix kernel = null;

            try
            {
                kernel = GenerateGaussianKernel(kernelSize, standardDeviation);
            }
            catch (ArgumentOutOfRangeException exception)
            {
                throw new ArgumentOutOfRangeException("Kernel size must be greater than 1 and be odd number",
                    exception);
            }

            var convolutedImageMatrix = MatrixUtils.ConvertMatrixToRGBMatrix(image.Convolute(kernel));
            MatrixUtils.CreateImageFromMatrix(convolutedImageMatrix, outputImagePath);
        }

        /// <summary>
        /// Creates kernel populated with values generated by Gaussian 2D formula
        /// </summary>
        /// <param name="size">kernel size (width and height)</param>
        /// <param name="standardDivination">gaussian standart deviation. </param>
        /// <returns></returns>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        private IMatrix GenerateGaussianKernel(int size, float standardDeviation)
        {
            if (size <= 1)
            {
                throw new ArgumentOutOfRangeException(nameof(size), "Size must be greater than 1");
            }

            if (size % 3 != 0)
            {
                throw new ArgumentOutOfRangeException(nameof(size), "Size must be odd number");
            }

            if (standardDeviation <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(standardDeviation),
                    "Standard deviation must be positive integer");
            }

            var kernel = new Matrix(size, size, typeof(FloatNumberMatrixData));
            var halfSize = (int) Math.Floor(size / 2f);

            for (int i = halfSize; i <= halfSize; i++)
            {
                for (int j = halfSize; j <= halfSize; j++)
                {
                    kernel.SetValue(i + halfSize, j + halfSize,
                        new FloatNumberMatrixData((float) Gaussian2D(j, i, standardDeviation)));
                }
            }

            return kernel;
        }

        /// <summary>
        /// Implementation of Gaussian for 2D
        /// </summary>
        private double Gaussian2D(int x, int y, float standardDeviation)
        {
            return
            (
                Math.Exp(-(((Math.Pow(x, 2) + Math.Pow(y, 2)) / (2 * Math.Pow(standardDeviation, 2)))))
                /
                (2 * Math.PI * Math.Pow(standardDeviation, 2))
            );
        }
    }
}